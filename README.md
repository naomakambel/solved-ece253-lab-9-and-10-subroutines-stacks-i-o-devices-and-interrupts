Download Link: https://assignmentchef.com/product/solved-ece253-lab-9-and-10-subroutines-stacks-i-o-devices-and-interrupts
<br>
The goal of this lab exercise is to continue to gain familiarity with assembly language programming, to learn more about subroutines, and to communicate with an I/O device by using memory-mapped I/O, and interrupts.

Part I

Write an assembly language program to sort a list of 32-bit unsigned numbers into descending order. The first 32-bit number in the list gives the number of items in the list and the remainder of the entries are the numbers to be sorted. The list of data must be sorted “in place”, meaning that you are not allowed to create a copy in memory of the list to do the sorting. The list you should sort, including the number count, can be defined using the .word directive at the end of your program as follows:

List:       .word       10, 1400, 45, 23, 5, 3, 8, 17, 4, 20, 33

Note that the first number in the list is 10, indicating that there are 10 numbers following it. In your code you should have a main program that loops through the list of numbers as needed to perform the sorting operation. Use a simple algorithm, such as a bubble sort. Provide pseudo code, similar to C code, that illustrates how your sorting algorithm works. Then, write an assembly language program.

As your main program loops through the list of numbers it will be necessary to compare the values of pairs of list elements to see if they need to be swapped. You are to use a subroutine, called SWAP, to compare such list elements. The SWAP subroutine is passed the address of a list element, compares it to the following element in the list, and swaps the two elements in memory if necessary. The SWAP subroutine should return 1 if a swap is performed, and 0 if not. Pass the address of the first list element to SWAP in register R0, and also pass the return value back to the main program in register R0.

Part II

Write a program that turns on one LEDR light at a time on the DE1-SoC board. First, the light <em>LEDR</em><sub>0 </sub>should be on, then <em>LEDR</em><sub>1</sub>, then <em>LEDR</em><sub>2</sub>, and so on. When you get to <em>LEDR</em><sub>9</sub>, the direction should be reversed. Only one LEDR light is ever on at one time. The effect should be a single light sweeping from right-to-left, then left-to-right, and so on.

Use a delay so that the light moves at some reasonable speed. To implement the delay, use the MPCORE Private Timer described in the lectures. When <em>KEY</em><sub>3 </sub>is pressed, the sweeping motion should stop. Pressing <em>KEY</em><sub>3 </sub>again should restart it.

To synchronize with the timer device in your main program use polled I/O by repeatedly reading the <em>F </em>bit in the timer’s status register. Also use polled I/O to deal with the pushbutton <em>KEYs</em>.

Part III

In Part II you used the timer to create a delay, and used polled I/O to synchronize with the timer. Also, you used polled I/O to check when <em>KEY</em><sub>3 </sub>was pressed.

In this part of the exercise, you are to create the same application, but relying entirely on interrupts instead of polled I/O. Interrupts have to be generated by both the timer and KEY port.

An outline of the main program that you need to use for this part is shown below.

.text

.global      start

start:

<em>… </em>initialize the IRQ stack pointer <em>…</em>

<em>… </em>initialize the SVC stack pointer <em>…</em>

<table width="576">

 <tbody>

  <tr>

   <td width="316">                  BL              CONFIG GIC</td>

   <td width="260">// configure the ARM generic interrupt controller</td>

  </tr>

  <tr>

   <td width="316">                  BL               CONFIG PRIV TIMER</td>

   <td width="260">// configure the MPCore private timer</td>

  </tr>

  <tr>

   <td width="316">                  BL               CONFIG KEYS<em>… </em>enable ARM processor interrupts <em>…</em></td>

   <td width="260">// configure the pushbutton KEYs</td>

  </tr>

  <tr>

   <td width="316">LDR      R6, =0xFF200000 MAIN:</td>

   <td width="260">// red LED base address</td>

  </tr>

  <tr>

   <td width="316">                  LDR            R4, LEDR PATTERN</td>

   <td width="260">// LEDR pattern; modified by timer ISR</td>

  </tr>

  <tr>

   <td width="316">                  STR           R4, [R6]</td>

   <td width="260">// write to red LEDs</td>

  </tr>

 </tbody>

</table>

B               MAIN

/* Configure the MPCore private timer to create interrupts every 1/10 second */

CONFIG PRIV TIMER:

<table width="470">

 <tbody>

  <tr>

   <td width="288">                  LDR          R0, =0xFFFEC600<em>… </em>code not shown</td>

   <td width="182">// Timer base address</td>

  </tr>

  <tr>

   <td width="288">                  MOV         PC, LR/* Configure the KEYS to generate an interrupt */ CONFIG KEYS:</td>

   <td width="182">// return</td>

  </tr>

  <tr>

   <td width="288">                  LDR          R0, =0xFF200050<em>… </em>code not shown</td>

   <td width="182">// KEYs base address</td>

  </tr>

  <tr>

   <td width="288">                  MOV         PC, LR.global        LEDR DIRECTIONLEDR DIRECTION:</td>

   <td width="182">// return</td>

  </tr>

  <tr>

   <td width="288">                  .word       0</td>

   <td width="182">// 0 means left, 1 means right</td>

  </tr>

 </tbody>

</table>

.global            LEDR PATTERN LEDR PATTERN:

.word       0x1

Store your main program in a file, for example <em>main.s</em>. Create three other files, called <em>exceptions.s</em>, <em>timer ISR.s</em>, and <em>key ISR.s</em>. The <em>exceptions.s </em>file should initialize the exception vector table and provide code for all exception handlers. It should also include the subroutine <em>CONFIG GIC</em>, which initializes the ARM Generic Interrupt Controller

The file <em>timer ISR.s </em>is the MPCORE Private Timer interrupt service routine. It has to modify the global variables <em>LEDR DIRECTION </em>and <em>LEDR PATTERN </em>that are declared in the main program above. The first of these variables specifies if the LEDR light is currently sweeping to the left or to the right, and the second variable sets which light is currently turned on. Finally, the file <em>KEY isr.s </em>is the pushbutton KEY interrupt service routine. It has to stop and restart the timer when <em>KEY</em><sub>3 </sub>is pressed.

Skeleton assembly language files are provided on the course BlackBoard with the lab writeup. Fill in the missing parts of these files to create your program.

Preparation and In-Lab Marks